# Architecture Separation Proposal: Brand Analytics vs Custom Campaigns

## Executive Summary

**Current Problem**: Data is being mixed between Brand Analytics (automatic campaigns) and Custom Campaigns, causing incorrect dashboard displays and confused insights.

**Root Cause**:
1. Database models lack proper campaign type differentiation
2. API queries don't filter by campaign type (automatic vs custom)
3. Same database tables are used for both types without separation
4. Community model has no campaign/brand relationship

---

## 1. Current Architecture Analysis

### 1.1 Database Schema Issues

#### âŒ PROBLEM: Community Model Has No Campaign Link
**File**: `backend/common/models.py:433-471`

```python
class Community(BaseModel):
    name = models.CharField(max_length=200)
    platform = models.CharField(max_length=20, choices=PLATFORM_CHOICES)
    # âŒ NO campaign foreign key
    # âŒ NO brand foreign key
    # Result: Communities are SHARED across ALL campaigns
```

**Impact**: Brand Analytics and Custom Campaigns share the same Community records

#### âœ… Models with Campaign Links (But Still Mixed)
- **PainPoint** - Has `campaign` FK (line 478)
- **Thread** - Has `campaign` FK (line 519)
- **Influencer** - Has `campaign` FK (line 290)

**Issue**: These models correctly link to campaigns, BUT queries don't distinguish between automatic vs custom campaigns.

### 1.2 API Query Issues

#### âŒ PROBLEM: Queries Don't Filter by Campaign Type

**File**: `backend/api/views.py:833-923` - `get_brand_dashboard_kpis()`

```python
# Line 840: Gets ALL campaigns for brand (both automatic AND custom)
brand_campaigns = Campaign.objects.filter(brand_id=brand_id, status='active')

# Line 844-848: Gets ALL communities regardless of brand
brand_communities = Community.objects.filter(
    echo_score__gte=7.0,
    is_active=True
) # âŒ No brand or campaign filtering!

# Line 862-866: Gets ALL pain points regardless of brand
brand_pain_points = PainPoint.objects.filter(
    growth_percentage__gte=50,
    created_at__gte=seven_days_ago
) # âŒ No campaign filtering!

# Line 870-873: Gets ALL threads regardless of brand
brand_threads = Thread.objects.filter(
    analyzed_at__gte=seven_days_ago
) # âŒ No campaign filtering!
```

**File**: `backend/api/views.py:1186-1230` - `get_brand_campaign_analytics()`

```python
# Line 1191: Gets ALL campaigns (automatic + custom)
brand_campaigns = Campaign.objects.filter(brand_id=brand_id)

# Line 1207-1217: Gets insights from ANY campaign (could be automatic or custom)
campaigns_with_insights = brand_campaigns.filter(
    metadata__insights__isnull=False
).order_by('-created_at')
```

**Impact**: Brand Analytics shows data from Custom Campaigns and vice versa

### 1.3 Data Collection Issues

**File**: `backend/agents/tasks.py:49-236` - `scout_reddit_task()`

```python
# Line 64-70: Processes campaigns without type distinction
if campaign_id:
    campaigns = Campaign.objects.filter(id=campaign_id, status='active')
else:
    campaigns = Campaign.objects.filter(status='active', brand__isnull=False)
```

**Issue**: Same collection logic for both automatic and custom campaigns

---

## 2. Proposed Solution: Complete Separation

### 2.1 Core Principle

**Brand Analytics** and **Custom Campaigns** should be COMPLETELY SEPARATE systems:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BRAND ANALYTICS                          â”‚
â”‚  (Automatic Campaign - Always Running)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Data Storage:                                              â”‚
â”‚  - BrandCommunity (NEW model)                               â”‚
â”‚  - BrandPainPoint (NEW model)                               â”‚
â”‚  - BrandThread (NEW model)                                  â”‚
â”‚  - BrandInfluencer (NEW model)                              â”‚
â”‚                                                             â”‚
â”‚  Collection:                                                â”‚
â”‚  - scout_brand_analytics_task()                             â”‚
â”‚  - Runs every X hours for brand monitoring                  â”‚
â”‚                                                             â”‚
â”‚  Insights:                                                  â”‚
â”‚  - AI-Powered Key Insights (6 insights)                     â”‚
â”‚  - Generated by Analyst Agent                               â”‚
â”‚  - Stored in Campaign.metadata['ai_insights']               â”‚
â”‚                                                             â”‚
â”‚  Dashboard Display:                                         â”‚
â”‚  - Brand Analytics section (top of dashboard)               â”‚
â”‚  - All KPI cards                                            â”‚
â”‚  - All charts (Heatmap, Community Watchlist, etc.)          â”‚
â”‚  - AI-Powered Key Insights                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   CUSTOM CAMPAIGNS                          â”‚
â”‚  (User-Created Campaigns - Scheduled)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Data Storage:                                              â”‚
â”‚  - CampaignCommunity (NEW model)                            â”‚
â”‚  - CampaignPainPoint (NEW model)                            â”‚
â”‚  - CampaignThread (NEW model)                               â”‚
â”‚  - CampaignInfluencer (NEW model)                           â”‚
â”‚                                                             â”‚
â”‚  Collection:                                                â”‚
â”‚  - scout_custom_campaign_task()                             â”‚
â”‚  - Runs based on user-defined schedule                      â”‚
â”‚  - Uses custom keywords, sources, filters                   â”‚
â”‚                                                             â”‚
â”‚  Insights:                                                  â”‚
â”‚  - Campaign AI Insights (structured objects)                â”‚
â”‚  - Generated by Analyst Agent                               â”‚
â”‚  - Stored in Campaign.metadata['insights']                  â”‚
â”‚                                                             â”‚
â”‚  Dashboard Display:                                         â”‚
â”‚  - Campaign Analytics section (bottom of dashboard)         â”‚
â”‚  - Campaign-specific metrics                                â”‚
â”‚  - Campaign AI Insights                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. Database Schema Changes Needed

### 3.1 Add Campaign Type Field to Campaign Model

**File**: `backend/common/models.py:84-132`

```python
class Campaign(BaseModel):
    CAMPAIGN_TYPE_CHOICES = [
        ('automatic', 'Automatic Brand Analytics'),
        ('custom', 'Custom Campaign'),
    ]

    # NEW FIELD
    campaign_type = models.CharField(
        max_length=20,
        choices=CAMPAIGN_TYPE_CHOICES,
        default='custom'
    )

    # Existing fields...
    name = models.CharField(max_length=255)
    brand = models.ForeignKey(Brand, ...)
    status = models.CharField(...)
    # ...
```

### 3.2 Option A: Add Brand Link to Existing Models (RECOMMENDED)

**Simpler approach - just add brand_id to existing models:**

```python
# Update Community Model
class Community(BaseModel):
    # ADD THESE FIELDS
    brand = models.ForeignKey(
        Brand,
        on_delete=models.CASCADE,
        related_name='communities',
        null=True,  # For backward compatibility
        blank=True
    )
    campaign = models.ForeignKey(
        Campaign,
        on_delete=models.CASCADE,
        related_name='communities',
        null=True,  # For backward compatibility
        blank=True
    )

    # Existing fields...
    name = models.CharField(max_length=200)
    platform = models.CharField(max_length=20)
    # ...

    class Meta:
        unique_together = ['platform', 'name', 'campaign']  # UPDATED

# Update PainPoint Model
class PainPoint(BaseModel):
    # ADD THIS FIELD
    brand = models.ForeignKey(
        Brand,
        on_delete=models.CASCADE,
        related_name='pain_points',
        null=True,
        blank=True
    )

    # Existing fields...
    campaign = models.ForeignKey(Campaign, ...)  # Already exists
    # ...

# Update Thread Model
class Thread(BaseModel):
    # ADD THIS FIELD
    brand = models.ForeignKey(
        Brand,
        on_delete=models.CASCADE,
        related_name='threads',
        null=True,
        blank=True
    )

    # Existing fields...
    campaign = models.ForeignKey(Campaign, ...)  # Already exists
    # ...

# Influencer already has brand FK (line 291) âœ…
```

### 3.3 Option B: Create Separate Models (MORE ISOLATION)

**Create completely separate models for Brand Analytics vs Custom Campaigns:**

```python
# ============= BRAND ANALYTICS MODELS =============

class BrandCommunity(BaseModel):
    """Communities tracked for Brand Analytics ONLY"""
    brand = models.ForeignKey(Brand, on_delete=models.CASCADE)
    name = models.CharField(max_length=200)
    platform = models.CharField(max_length=20)
    # ... all community fields

    class Meta:
        db_table = 'brand_communities'
        unique_together = ['brand', 'platform', 'name']


class BrandPainPoint(BaseModel):
    """Pain points for Brand Analytics ONLY"""
    brand = models.ForeignKey(Brand, on_delete=models.CASCADE)
    community = models.ForeignKey(BrandCommunity, on_delete=models.CASCADE)
    keyword = models.CharField(max_length=100)
    # ... all pain point fields

    class Meta:
        db_table = 'brand_pain_points'


class BrandThread(BaseModel):
    """Threads for Brand Analytics ONLY"""
    brand = models.ForeignKey(Brand, on_delete=models.CASCADE)
    community = models.ForeignKey(BrandCommunity, on_delete=models.CASCADE)
    thread_id = models.CharField(max_length=100)
    # ... all thread fields

    class Meta:
        db_table = 'brand_threads'


class BrandInfluencer(BaseModel):
    """Influencers for Brand Analytics ONLY"""
    brand = models.ForeignKey(Brand, on_delete=models.CASCADE)
    username = models.CharField(max_length=255)
    # ... all influencer fields

    class Meta:
        db_table = 'brand_influencers'


# ============= CUSTOM CAMPAIGN MODELS =============

class CampaignCommunity(BaseModel):
    """Communities tracked for Custom Campaigns ONLY"""
    campaign = models.ForeignKey(Campaign, on_delete=models.CASCADE)
    name = models.CharField(max_length=200)
    platform = models.CharField(max_length=20)
    # ... all community fields

    class Meta:
        db_table = 'campaign_communities'
        unique_together = ['campaign', 'platform', 'name']


class CampaignPainPoint(BaseModel):
    """Pain points for Custom Campaigns ONLY"""
    campaign = models.ForeignKey(Campaign, on_delete=models.CASCADE)
    community = models.ForeignKey(CampaignCommunity, on_delete=models.CASCADE)
    keyword = models.CharField(max_length=100)
    # ... all pain point fields

    class Meta:
        db_table = 'campaign_pain_points'


class CampaignThread(BaseModel):
    """Threads for Custom Campaigns ONLY"""
    campaign = models.ForeignKey(Campaign, on_delete=models.CASCADE)
    community = models.ForeignKey(CampaignCommunity, on_delete=models.CASCADE)
    thread_id = models.CharField(max_length=100)
    # ... all thread fields

    class Meta:
        db_table = 'campaign_threads'


class CampaignInfluencer(BaseModel):
    """Influencers for Custom Campaigns ONLY"""
    campaign = models.ForeignKey(Campaign, on_delete=models.CASCADE)
    username = models.CharField(max_length=255)
    # ... all influencer fields

    class Meta:
        db_table = 'campaign_influencers'
```

**Recommendation**: **Option A** is simpler and requires less code changes. **Option B** provides complete isolation but requires more refactoring.

---

## 4. API Changes Needed

### 4.1 Brand Analytics API Changes

**File**: `backend/api/views.py`

```python
def get_brand_dashboard_kpis(brand_id, date_from, date_to):
    """Calculate KPI metrics for Brand Analytics ONLY."""

    # âœ… FIX: Filter by automatic campaign only
    automatic_campaign = Campaign.objects.filter(
        brand_id=brand_id,
        campaign_type='automatic',  # NEW: Filter by type
        status='active'
    ).first()

    if not automatic_campaign:
        return empty_kpis()

    # âœ… FIX: Filter communities by brand
    brand_communities = Community.objects.filter(
        brand_id=brand_id,  # NEW: Filter by brand
        echo_score__gte=7.0,
        is_active=True
    )

    # âœ… FIX: Filter pain points by automatic campaign
    brand_pain_points = PainPoint.objects.filter(
        campaign=automatic_campaign,  # NEW: Use automatic campaign
        growth_percentage__gte=50
    )

    # âœ… FIX: Filter threads by automatic campaign
    brand_threads = Thread.objects.filter(
        campaign=automatic_campaign  # NEW: Use automatic campaign
    )

    # ... rest of logic


def get_brand_top_pain_points(brand_id, date_from, date_to):
    """Get pain points for Brand Analytics ONLY."""

    # âœ… FIX: Get automatic campaign only
    automatic_campaign = Campaign.objects.filter(
        brand_id=brand_id,
        campaign_type='automatic'  # NEW
    ).first()

    if not automatic_campaign:
        return []

    # âœ… FIX: Filter by automatic campaign
    top_pain_points = PainPoint.objects.filter(
        campaign=automatic_campaign,  # CHANGED
        growth_percentage__gt=0
    ).order_by('-growth_percentage')[:5]

    # ... rest of logic


def get_brand_community_watchlist(brand_id):
    """Get communities for Brand Analytics ONLY."""

    # âœ… FIX: Filter by brand
    communities = Community.objects.filter(
        brand_id=brand_id,  # NEW
        is_active=True
    ).order_by('-echo_score')[:10]

    # ... rest of logic


def get_brand_analysis_summary(request, brand_id):
    """Get AI-Powered Key Insights for Brand Analytics."""

    # âœ… FIX: Get automatic campaign only
    automatic_campaign = Campaign.objects.filter(
        brand_id=brand_id,
        campaign_type='automatic'  # NEW
    ).first()

    # Get Brand Analytics data (already filtered above)
    brand_kpis = get_brand_dashboard_kpis(brand_id, None, None)
    brand_communities = get_brand_community_watchlist(brand_id)
    brand_pain_points = get_brand_top_pain_points(brand_id, None, None)
    brand_influencers = get_brand_influencer_pulse(brand_id)

    # Generate AI insights using Analytics Agent
    from agents.analyst import generate_ai_powered_insights_from_brand_analytics
    ai_insights = generate_ai_powered_insights_from_brand_analytics(
        brand, kpis, communities, pain_points, influencers
    )

    # âœ… Store in automatic campaign metadata
    if automatic_campaign:
        automatic_campaign.metadata['ai_insights'] = ai_insights
        automatic_campaign.save()

    return Response({
        'summary': {
            'key_insights': ai_insights,  # 6 simple strings
            # ...
        }
    })
```

### 4.2 Custom Campaign Analytics API Changes

```python
def get_brand_campaign_analytics(brand_id, date_from, date_to):
    """Get Campaign Analytics for Custom Campaigns ONLY."""

    # âœ… FIX: Filter by custom campaigns only
    custom_campaigns = Campaign.objects.filter(
        brand_id=brand_id,
        campaign_type='custom'  # NEW: Only custom campaigns
    )

    # Campaign performance metrics
    total_campaigns = custom_campaigns.count()
    active_campaigns = custom_campaigns.filter(status='active').count()

    # Get campaign insights from latest CUSTOM campaign with insights
    campaign_insights = []
    campaigns_with_insights = custom_campaigns.filter(
        metadata__insights__isnull=False
    ).exclude(
        metadata__insights=[]
    ).order_by('-created_at')

    if campaigns_with_insights.exists():
        latest_campaign = campaigns_with_insights.first()
        campaign_insights = latest_campaign.metadata.get('insights', [])

    return {
        'total_campaigns': total_campaigns,
        'active_campaigns': active_campaigns,
        'insights': campaign_insights,  # Custom campaign insights only
        # ...
    }


def get_custom_campaign_detail(campaign_id):
    """Get detailed data for a specific custom campaign."""

    campaign = Campaign.objects.get(id=campaign_id, campaign_type='custom')

    # Get data for THIS campaign only
    communities = Community.objects.filter(campaign=campaign)
    pain_points = PainPoint.objects.filter(campaign=campaign)
    threads = Thread.objects.filter(campaign=campaign)
    influencers = Influencer.objects.filter(campaign=campaign)

    return {
        'campaign': campaign_data,
        'communities': communities_data,
        'pain_points': pain_points_data,
        'threads': threads_data,
        'influencers': influencers_data,
        'insights': campaign.metadata.get('insights', [])
    }
```

---

## 5. Data Collection Changes Needed

### 5.1 Separate Celery Tasks

**File**: `backend/agents/tasks.py`

```python
@shared_task(base=CallbackTask, bind=True)
def scout_brand_analytics_task(self, brand_id: int):
    """
    Collect data for Brand Analytics (automatic campaign) ONLY.

    This runs on a schedule for continuous brand monitoring.
    """
    logger.info(f"ğŸ” Starting Brand Analytics data collection for brand {brand_id}")

    try:
        # Get automatic campaign for this brand
        automatic_campaign = Campaign.objects.filter(
            brand_id=brand_id,
            campaign_type='automatic',
            status='active'
        ).first()

        if not automatic_campaign:
            logger.warning(f"No automatic campaign found for brand {brand_id}")
            return {"status": "skipped", "reason": "no_automatic_campaign"}

        brand = automatic_campaign.brand

        # Collect data using scout agent
        brand_keywords = [brand.name] + brand.primary_keywords
        scout_config = {
            'search_depth': 'comprehensive',
            'focus': 'brand_monitoring',
            'include_sentiment': True,
            'focus_areas': ['pain_points', 'feedback', 'sentiment']
        }

        collected_data = await collect_real_brand_data(
            brand.name,
            brand_keywords,
            scout_config
        )

        # âœ… Store in Brand Analytics models (with brand_id)
        store_brand_analytics_data(collected_data, brand, automatic_campaign)

        # âœ… Generate Brand Analytics insights
        generate_brand_analytics_insights(brand, automatic_campaign, collected_data)

        logger.info(f"âœ… Brand Analytics data collected for {brand.name}")
        return {"status": "success", "brand_id": brand_id}

    except Exception as e:
        logger.error(f"Brand Analytics collection failed: {e}")
        raise self.retry(exc=e)


@shared_task(base=CallbackTask, bind=True)
def scout_custom_campaign_task(self, campaign_id: int):
    """
    Collect data for a specific Custom Campaign ONLY.

    This runs on user-defined schedule with custom parameters.
    """
    logger.info(f"ğŸ” Starting Custom Campaign data collection for campaign {campaign_id}")

    try:
        # Get custom campaign
        campaign = Campaign.objects.filter(
            id=campaign_id,
            campaign_type='custom',
            status='active'
        ).first()

        if not campaign:
            logger.warning(f"No custom campaign found: {campaign_id}")
            return {"status": "skipped", "reason": "no_custom_campaign"}

        brand = campaign.brand

        # Collect data using campaign-specific parameters
        campaign_keywords = campaign.keywords or [brand.name]
        scout_config = {
            'search_depth': 'comprehensive',
            'focus': 'custom_campaign',
            'sources': campaign.sources,
            'exclude_keywords': campaign.exclude_keywords,
            'include_sentiment': True
        }

        collected_data = await collect_real_campaign_data(
            brand.name,
            campaign_keywords,
            scout_config
        )

        # âœ… Store in Custom Campaign models (with campaign_id)
        store_custom_campaign_data(collected_data, brand, campaign)

        # âœ… Generate Custom Campaign insights
        generate_custom_campaign_insights(campaign, brand, collected_data)

        logger.info(f"âœ… Custom Campaign data collected for {campaign.name}")
        return {"status": "success", "campaign_id": campaign_id}

    except Exception as e:
        logger.error(f"Custom Campaign collection failed: {e}")
        raise self.retry(exc=e)
```

### 5.2 Separate Storage Functions

**File**: `backend/agents/nodes.py`

```python
def store_brand_analytics_data(collected_data, brand, automatic_campaign):
    """
    Store data for Brand Analytics ONLY.
    Links all data to brand and automatic campaign.
    """
    logger.info(f"ğŸ’¾ Storing Brand Analytics data for {brand.name}")

    # Store communities (link to brand + campaign)
    for community_data in collected_data.get("communities", []):
        community, created = Community.objects.get_or_create(
            name=community_data["name"],
            platform=community_data["platform"],
            brand=brand,  # âœ… NEW: Link to brand
            campaign=automatic_campaign,  # âœ… NEW: Link to automatic campaign
            defaults={...}
        )

    # Store pain points (link to brand + campaign)
    for pain_point_data in collected_data.get("pain_points", []):
        community = Community.objects.filter(
            brand=brand,  # âœ… Filter by brand
            campaign=automatic_campaign
        ).first()

        if community:
            PainPoint.objects.update_or_create(
                keyword=pain_point_data["keyword"],
                campaign=automatic_campaign,  # âœ… Link to automatic campaign
                brand=brand,  # âœ… NEW: Link to brand
                community=community,
                defaults={...}
            )

    # Store threads (link to brand + campaign)
    for thread_data in collected_data.get("threads", []):
        community = Community.objects.filter(
            name=thread_data.get("community"),
            brand=brand,  # âœ… Filter by brand
            campaign=automatic_campaign
        ).first()

        if community:
            Thread.objects.update_or_create(
                thread_id=thread_data["thread_id"],
                campaign=automatic_campaign,  # âœ… Link to automatic campaign
                brand=brand,  # âœ… NEW: Link to brand
                community=community,
                defaults={...}
            )

    # Store influencers (already has brand FK)
    for influencer_data in collected_data.get("influencers", []):
        Influencer.objects.update_or_create(
            username=influencer_data["username"],
            campaign=automatic_campaign,  # âœ… Link to automatic campaign
            brand=brand,  # Already has this field
            defaults={...}
        )


def store_custom_campaign_data(collected_data, brand, campaign):
    """
    Store data for Custom Campaign ONLY.
    Links all data to campaign (and brand).
    """
    logger.info(f"ğŸ’¾ Storing Custom Campaign data for {campaign.name}")

    # Store communities (link to campaign)
    for community_data in collected_data.get("communities", []):
        community, created = Community.objects.get_or_create(
            name=community_data["name"],
            platform=community_data["platform"],
            brand=brand,  # âœ… Link to brand
            campaign=campaign,  # âœ… Link to THIS campaign
            defaults={...}
        )

    # Store pain points (link to campaign)
    for pain_point_data in collected_data.get("pain_points", []):
        community = Community.objects.filter(
            brand=brand,
            campaign=campaign  # âœ… Filter by THIS campaign
        ).first()

        if community:
            PainPoint.objects.update_or_create(
                keyword=pain_point_data["keyword"],
                campaign=campaign,  # âœ… Link to THIS campaign
                brand=brand,  # âœ… Link to brand
                community=community,
                defaults={...}
            )

    # Similar for threads, influencers...
```

---

## 6. Implementation Steps

### Phase 1: Database Changes (1-2 days)
1. Add `campaign_type` field to Campaign model
2. Add `brand` FK to Community, PainPoint, Thread models
3. Create and run Django migrations
4. Update existing campaigns: set `campaign_type='automatic'` for brand analytics campaigns
5. Update existing data: link to brands where possible

### Phase 2: Data Collection Changes (2-3 days)
1. Create `scout_brand_analytics_task()` for automatic campaigns
2. Create `scout_custom_campaign_task()` for custom campaigns
3. Update `store_brand_analytics_data()` to link data to brand
4. Update `store_custom_campaign_data()` to link data to campaign
5. Update Celery beat schedule to use new tasks

### Phase 3: API Changes (2-3 days)
1. Update `get_brand_dashboard_kpis()` to filter by automatic campaign
2. Update `get_brand_top_pain_points()` to filter by automatic campaign
3. Update `get_brand_community_watchlist()` to filter by brand
4. Update `get_brand_campaign_analytics()` to filter by custom campaigns only
5. Update `get_brand_analysis_summary()` to use automatic campaign data

### Phase 4: Testing & Validation (2 days)
1. Test Brand Analytics with automatic campaign
2. Test Custom Campaigns independently
3. Verify no data mixing occurs
4. Verify AI insights are generated correctly for each type
5. Test dashboard displays correct data

### Total Estimated Time: **7-10 days**

---

## 7. Migration Strategy

### For Existing Data:

```python
# Migration script to separate existing data
def migrate_existing_data():
    """
    Migrate existing data to new separated architecture.
    """

    # 1. Mark automatic campaigns
    Campaign.objects.filter(
        metadata__is_auto_campaign=True
    ).update(campaign_type='automatic')

    # 2. Mark custom campaigns
    Campaign.objects.filter(
        metadata__is_auto_campaign=False
    ).update(campaign_type='custom')

    Campaign.objects.filter(
        metadata__is_auto_campaign__isnull=True
    ).update(campaign_type='custom')  # Default to custom

    # 3. Link communities to brands (via campaigns)
    for community in Community.objects.all():
        # Find most recent campaign using this community
        thread = Thread.objects.filter(community=community).first()
        if thread and thread.campaign:
            community.brand = thread.campaign.brand
            community.campaign = thread.campaign
            community.save()

    # 4. Link pain points to brands
    for pp in PainPoint.objects.all():
        if pp.campaign:
            pp.brand = pp.campaign.brand
            pp.save()

    # 5. Link threads to brands
    for thread in Thread.objects.all():
        if thread.campaign:
            thread.brand = thread.campaign.brand
            thread.save()
```

---

## 8. Recommendation

**I recommend Option A (Add brand FK to existing models)** because:

1. âœ… **Less refactoring** - Existing code mostly works, just needs filtering fixes
2. âœ… **Backward compatible** - Can migrate existing data
3. âœ… **Cleaner separation** - `campaign_type` field clearly distinguishes types
4. âœ… **Simpler queries** - Just add `campaign_type='automatic'` or `'custom'` filters
5. âœ… **Flexible** - Can still share logic between types if needed

Option B (Separate models) provides more isolation but requires:
- Duplicate model definitions
- Duplicate storage logic
- Duplicate API logic
- More complex migrations

---

## 9. Next Steps

Would you like me to:

1. **Implement Phase 1** - Database schema changes with migrations?
2. **Create migration script** - To separate existing data?
3. **Implement Phase 2** - Update data collection tasks?
4. **Implement Phase 3** - Update API queries?
5. **All of the above** - Complete implementation?

Please let me know which approach you prefer (Option A or B) and I'll proceed with the implementation.
